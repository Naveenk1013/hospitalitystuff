<!DOCTYPE HTML>
<html>
	<head>
		<title>Advanced Algorithms - Lecture Notes</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
			<header id="header">
				
				<div class="content">
					<div class="inner">
						<h1>Advanced Algorithms</h1>
						<p>Lecture Notes – Week 5: Graph Traversal & Dynamic Programming</p>
					</div>
				</div>
				<nav>
					<ul>
					<p>	<li><a href="../course/gtu.html">Back</a></li>
						<li><a href="../index.html">Home</a></li>
						</ul>
						
				</nav>
			</header>
		</p>

<div class="content">

			<!-- Main -->
			 
			<div class="inner">

	
					<h2 class="major">Graph Traversal Techniques</h2>

					<p>
						In computer science, <strong>graph traversal</strong> refers to the process of visiting (checking and/or updating) each vertex in a graph. Such traversals are classified by the order in which the vertices are visited. Two classic approaches are:
					</p>

					<h3>Breadth-First Search (BFS)</h3>
					<p>
						BFS explores all neighbors at the present depth before moving on to nodes at the next depth level. It uses a <em>queue</em> data structure and guarantees the shortest path in unweighted graphs.
					</p>
					<pre><code>function BFS(graph, start) {
  const visited = new Set();
  const queue = [start];
  visited.add(start);

  while (queue.length > 0) {
    const node = queue.shift();
    console.log(node);
    for (const neighbor of graph[node]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }
}</code></pre>

					<h3>Depth-First Search (DFS)</h3>
					<p>
						DFS explores as ar as possible along each branch before backtracking. It can be implemented recursively or with a <em>stack</em>.
					</p>

					<blockquote>
						“DFS is the backbone of many advanced algorithms, including topological sorting and cycle detection.”
					</blockquote>

					<h2 class="major" id="summary">Dynamic Programming</h2>
					<p>
						Dynamic Programming (DP) is a method for solving complex problems by breaking them into simpler subproblems. It is applicable when the subproblems overlap.
					</p>
					<ul>
						<li><strong>Optimal substructure</strong>: optimal solution contains optimal solutions to subproblems.</li>
						<li><strong>Overlapping subproblems</strong>: subproblems recur many times.</li>
					</ul>

					<h3>Example: Fibonacci Sequence</h3>
					<p>
						Naive recursion has exponential time. With memoization:
					</p>
					<pre><code>const fib = (n, memo = {}) => {
  if (n in memo) return memo[n];
  if (n <= 2) return 1;
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
};</code></pre>
				</article>

			</div>
</div>
			<!-- Footer -->
			<footer id="footer">
				<p class="copyright">&copy; Hospitalitystuff: <a href="https://LANCEALOT.IN">LANCEALOT</a>.</p>
			</footer>

		</div>

		<!-- BG -->
		<div id="bg"></div>

		<!-- Scripts -->
		<script src="../assets/js/jquery.min.js"></script>
		<script src="../assets/js/browser.min.js"></script>
		<script src="../assets/js/breakpoints.min.js"></script>
		<script src="../assets/js/util.js"></script>
		<script src="../assets/js/main.js"></script>


	</body>
</html>